var b=Object.create;var v=Object.defineProperty;var k=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,C=Object.prototype.hasOwnProperty;var K=(o,n)=>()=>(n||o((n={exports:{}}).exports,n),n.exports);var S=(o,n,a,s)=>{if(n&&typeof n=="object"||typeof n=="function")for(let t of f(n))!C.call(o,t)&&t!==a&&v(o,t,{get:()=>n[t],enumerable:!(s=k(n,t))||s.enumerable});return o};var w=(o,n,a)=>(a=o!=null?b(g(o)):{},S(n||!o||!o.__esModule?v(a,"default",{value:o,enumerable:!0}):a,o));var u=K((_,p)=>{"use strict";p.exports=function(){throw new Error("ws does not work in the browser. Browser clients must use the native WebSocket object")}});var c=class{info;chatroom;constructor(n,a){this.info=n,this.chatroom=a}get id(){return this.info.id}get name(){return this.info.user.username}get slug(){return this.info.slug}get chatroomId(){return this.info.chatroom.id}static toLogin(n){let a=n.trim().toLowerCase();return a.startsWith("#")?a.slice(1):a}toString(){return this.name}};import{URLSearchParams as y}from"url";var d=class{listeners=new Map;on(n,a){return this.listeners.has(n)||this.listeners.set(n,new Set),this.listeners.get(n).add(a),this}off(n,a){return this.listeners.get(n)?.delete(a),this}emit(n,...a){if(!this.listeners.has(n)){if(n==="error")throw a[0]instanceof Error?a[0]:new Error("Uncaught error emitted",{cause:a[0]});return!1}for(let s of this.listeners.get(n))s(...a);return!0}};var i=o=>{try{return JSON.parse(o)}catch{return null}},I="wss://ws-us2.pusher.com/app/32cbd69e4b950bf97679",l=class extends d{socket;wasCloseCalled=!1;reconnectAttempts=0;pingInterval;socketSession={activity_timeout:120,socket_id:""};reconnectEnabled;reconnectMaxAttempts;reconnectInitialTimeout;reconnectMaxTimeout;channels=new Map;channelsByChatroomId=new Map;constructor(n={}){super(),this.reconnectEnabled=n.reconnect??!0,this.reconnectMaxAttempts=n.reconnectMaxAttempts??1/0,this.reconnectInitialTimeout=n.reconnectInitialTimeout??1e3,this.reconnectMaxTimeout=n.reconnectMaxTimeout??6e4,n.channels&&n.channels.forEach(a=>this.join(a))}isConnected(){return this.socket?.readyState===1}connect(){if(this.isConnected())throw new Error("Client is already connected.");this.wasCloseCalled=!1,this.createWebSocket().catch(n=>this.emit("error",n))}async createWebSocket(){let n=new y({protocol:"7",client:"js",version:"7.4.0",flash:"false"}),a=`${I}?${n.toString()}`;if(typeof window<"u"&&typeof window.WebSocket<"u")this.socket=new window.WebSocket(a),this.socket.onopen=()=>this.onSocketOpen(),this.socket.onmessage=s=>this.onSocketMessage(s.data),this.socket.onclose=s=>this.onSocketClose(s.code,s.reason),this.socket.onerror=()=>this.onSocketError(new Error("WebSocket error"));else{let{default:s}=await Promise.resolve().then(()=>w(u(),1));this.socket=new s(a),this.socket.on("open",()=>this.onSocketOpen()),this.socket.on("message",t=>this.onSocketMessage(t)),this.socket.on("close",(t,e)=>this.onSocketClose(t,e.toString())),this.socket.on("error",t=>this.onSocketError(t))}}close(){this.socket&&(this.wasCloseCalled=!0,this.socket.close())}async reconnect(){if(this.isConnected()&&this.socket.close(),this.reconnectAttempts>=this.reconnectMaxAttempts){this.emit("error",new Error("Maximum reconnect attempts reached."));return}this.reconnectAttempts++;let n=Math.min(this.reconnectInitialTimeout*1.23**this.reconnectAttempts,this.reconnectMaxTimeout);this.emit("reconnecting"),await new Promise(a=>setTimeout(a,n)),this.connect()}onSocketOpen(){this.reconnectAttempts=0,this.channels.forEach(n=>this.subscribeToChannel(n))}onSocketClose(n,a){clearInterval(this.pingInterval),!this.wasCloseCalled&&this.reconnectEnabled?this.reconnect():this.emit("disconnected",a||`Socket closed with code ${n}`)}onSocketError(n){this.emit("error",n)}onSocketMessage(n){let a=n.toString();this.emit("raw",a);let s=i(a);if(!s)return;let t;if(s.channel){let e=s.channel.match(/^chatrooms\.(\d+)\.v2$/);if(e){let r=parseInt(e[1],10);t=this.channelsByChatroomId.get(r)}}switch(s.event){case"pusher:connection_established":{let e=i(s.data);e&&(this.socketSession=e,this.startPing(),this.emit("connected"));break}case"pusher_internal:subscription_succeeded":{t&&this.emit("join",t);break}case"pusher:pong":break;case"pusher:error":{i(s.data)?.code===4200&&this.reconnect();break}case"App\\Events\\ChatMessageEvent":{let e=i(s.data);e&&t&&this.emit("message",e,t);break}case"App\\Events\\SubscriptionEvent":{let e=i(s.data);e&&t&&this.emit("subscription",e,t);break}case"GiftedSubscriptionsEvent":{let e=i(s.data);e&&t&&this.emit("giftedSubscriptions",e,t);break}case"App\\Events\\StreamHostEvent":{let e=i(s.data);e&&t&&this.emit("streamHost",e,t);break}case"App\\Events\\UserBannedEvent":{let e=i(s.data);e&&t&&this.emit("userBanned",e,t);break}case"App\\Events\\UserUnbannedEvent":{let e=i(s.data);e&&t&&this.emit("userUnbanned",e,t);break}case"App\\Events\\MessageDeletedEvent":{let e=i(s.data);e&&t&&this.emit("messageDeleted",e,t);break}case"App\\Events\\PinnedMessageCreatedEvent":{let e=i(s.data);e&&t&&this.emit("pinnedMessageCreated",e,t);break}case"App\\Events\\PinnedMessageDeletedEvent":{let e=i(s.data);e&&t&&this.emit("pinnedMessageDeleted",e,t);break}case"App\\Events\\ChatroomUpdatedEvent":{let e=i(s.data);e&&t&&this.emit("chatroomUpdated",e,t);break}case"App\\Events\\PollUpdateEvent":{let e=i(s.data);e&&t&&this.emit("pollUpdate",e,t);break}case"App\\Events\\PollDeleteEvent":{t&&this.emit("pollDelete",t);break}case"App\\Events\\StreamerIsLive":{let e=i(s.data);e&&t&&this.emit("streamerIsLive",e,t);break}case"App\\Events\\StopStreamBroadcast":{let e=i(s.data);e&&t&&this.emit("stopStreamBroadcast",e,t);break}case"GoalCreatedEvent":{let e=i(s.data);e&&t&&this.emit("goalCreated",e,t);break}case"GoalCanceledEvent":{let e=i(s.data);e&&t&&this.emit("goalCanceled",e,t);break}case"GoalProgressUpdateEvent":{let e=i(s.data);e&&t&&this.emit("goalProgressUpdate",e,t);break}case"App\\Events\\LivestreamUpdated":{let e=i(s.data);e&&t&&this.emit("livestreamUpdated",e,t);break}case"PredictionCreated":{let e=i(s.data);e&&t&&this.emit("predictionCreated",e,t);break}case"PredictionUpdated":{let e=i(s.data);e&&t&&this.emit("predictionUpdated",e,t);break}case"RewardRedeemedEvent":{let e=i(s.data);e&&t&&this.emit("rewardRedeemed",e,t);break}case"App\\Events\\ChannelSubscriptionEvent":{let e=i(s.data);e&&t&&this.emit("channelSubscription",e,t);break}case"App\\Events\\LuckyUsersWhoGotGiftSubscriptionsEvent":{let e=i(s.data);e&&t&&this.emit("luckyUsersWhoGotGiftSubscriptions",e,t);break}case"App\\Events\\VideoPrivatedEvent":{let e=i(s.data);e&&t&&this.emit("videoPrivated",e,t);break}case"GiftsLeaderboardUpdated":{let e=i(s.data);e&&t&&this.emit("giftsLeaderboardUpdated",e,t);break}case"App\\Events\\ChatMoveToSupportedChannelEvent":{let e=i(s.data);e&&t&&this.emit("chatMoveToSupportedChannel",e,t);break}}}sendPusher(n,a="subscribe"){this.isConnected()&&this.socket.send(JSON.stringify({event:`pusher:${a}`,data:{auth:"",channel:n}}))}startPing(){clearInterval(this.pingInterval),this.pingInterval=setInterval(()=>{this.isConnected()&&this.socket.send(JSON.stringify({event:"pusher:ping",data:{}}))},this.socketSession.activity_timeout*1e3)}subscribeToChannel(n){this.sendPusher(`chatrooms.${n.chatroomId}.v2`),this.sendPusher(`chatroom_${n.chatroomId}`),this.sendPusher(`channel_${n.id}`),this.sendPusher(`channel.${n.id}`),this.sendPusher(`predictions-channel-${n.id}`)}async join(n){let a=c.toLogin(n);if(this.channels.has(a))return this.channels.get(a);try{let s=await fetch(`https://kick.com/api/v2/channels/${a}/info`,{cache:"no-cache"});if(!s.ok)throw new Error(`Failed to fetch channel info for ${a}: ${s.statusText}`);let t=await s.json(),e=await fetch(`https://kick.com/api/v2/channels/${a}/chatroom`,{cache:"no-cache"});if(!e.ok)throw new Error(`Failed to fetch chatroom info for ${a}: ${e.statusText}`);let r=await e.json(),h=new c(t,r);return this.channels.set(a,h),this.channelsByChatroomId.set(h.chatroomId,h),this.isConnected()&&this.subscribeToChannel(h),await this.waitForEvent("join",E=>E.slug===a)}catch(s){this.channels.delete(a);let t=Array.from(this.channelsByChatroomId.values()).find(e=>e.slug===a);throw t&&this.channelsByChatroomId.delete(t.chatroomId),this.emit("error",s),s}}part(n){let a=c.toLogin(n),s=this.channels.get(a);s&&(this.isConnected()&&(this.sendPusher(`chatrooms.${s.chatroomId}.v2`,"unsubscribe"),this.sendPusher(`chatroom_${s.chatroomId}`,"unsubscribe"),this.sendPusher(`channel_${s.id}`,"unsubscribe"),this.sendPusher(`channel.${s.id}`,"unsubscribe"),this.sendPusher(`predictions-channel-${s.id}`,"unsubscribe")),this.channels.delete(a),this.channelsByChatroomId.delete(s.chatroomId),this.emit("part",s,"Disconnected by user"))}waitForEvent(n,a,s=1e4){return new Promise((t,e)=>{let r=(...m)=>{a(...m)&&(this.off(n,r),clearTimeout(h),t(m[0]))},h=setTimeout(()=>{this.off(n,r),e(new Error(`Timed out waiting for event: ${n}`))},s);this.on(n,r)})}};var D={KickChat:l};export{c as KiChannel,l as KickChat,D as default};
//# sourceMappingURL=kichat.js.browser.min.mjs.map
